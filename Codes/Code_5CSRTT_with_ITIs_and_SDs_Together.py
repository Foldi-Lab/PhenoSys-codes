def f5CSRTT_ITIs_SDs_Together(import_location, export_location, add_data_to_new_file, add_data_to_original_file):        import os    import pandas as pd    from openpyxl import load_workbook    import sys    from tqdm import tqdm        # Define functions for color coding.        def text_color(val):                val = str(val)        if val == 'correct':            color = '#4E7C3E' # Dark green for 'correct'        elif val == 'incorrect':            color = '#9C1B14' # Dark red for 'incorrect'        elif val == 'omission':            color = '#9C5600' # Dark yellow for 'omission'        elif val == 'iti':            color = '#833C0C' # Dark brown for 'ITI'        elif val == 'premature':            color = '#FFFFFF' # White for 'premature'        elif val == 'perseverative':            color = '#4472C4' # Blue for 'perseverative'        elif val == 'start exp':            color = '#FFFFFF' # White for 'start exp'        elif val == 'end exp':            color = '#FFFFFF' # White for 'end exp'                    elif val == '12':            color = '#C65911' # Orange for 'ITI 12'        elif val == '10':            color = '#7030A0' # Purple for 'ITI 10'        elif val == '8':            color = '#4E7C3E' # Dark green for 'ITI 8'        elif val == '5':            color = '#9C5600' # Dark yellow for 'ITI 5'        elif val == '2':            color = '#9C1B14' # Dark red for 'ITI 2'            else:            color = 'black'                    return 'color: %s' % color        def cell_color(val):                val = str(val)        if val == 'correct':            color = '#C3EFCC' # Green for 'correct'        elif val == 'incorrect':            color = '#FBC4CD' # Red for 'incorrect'        elif val == 'omission':            color = '#FCEB9C' # Yellow for 'omission'        elif val == 'iti':            color = '#F8CBAD' # Skin colour for 'ITI'        elif val == 'premature':            color = '#808080' # Grey for 'premature'        elif val == 'perseverative':            color = '#D9E1F2' # Light blue for 'perseverative'        elif val == 'start exp':            color = '#6C2C9D' # Purple for 'start exp'        elif val == 'end exp':            color = '#000000' # Black for 'end exp'                    elif val == '12':            color = '#DBDBDB' # Grey for 'ITI 12'        elif val == '10':            color = '#C6E0B4' # Light green for 'ITI 10'        elif val == '8':            color = '#C3EFCC' # Green for 'ITI 8'        elif val == '5':            color = '#FCEB9C' # Yellow for 'ITI 5'        elif val == '2':            color = '#FBC4CD' # Red for 'ITI 2'            else:            color = 'none'                    return 'background-color: %s' % color        # Create a loop over every excel file in the import location.        import_files = [file for file in os.listdir(import_location) if (file.endswith(".xlsx") and file.startswith("~$")==False)]        for filename in tqdm(import_files, ncols=70):                # Import the excel data                import_name = filename        import_destination = import_location + import_name        export_name = '(ITIs and SDs Together) Organised ' + import_name        export_destination = export_location + export_name                df = pd.read_excel(import_destination, sheet_name=0, usecols=['DateTime','IdRFID','IdLabel','outLabel','SystemMsg','MsgValue1','MsgValue2','MsgValue3'])        #df = pd.read_excel(import_destination, sheet_name=0, usecols="A,B,C,M,N,O,P,Q")                # Create an ITI value of 5 next to each 'start exp' event.        for i in range(len(df['SystemMsg'])):            if df.at[i,'SystemMsg'] == 'start exp':                df.at[i,'MsgValue1'] = 5                        # Delete rows in the imported data if the entry in column 'SystemMsg' is not 'end exp', 'incorrect', 'omission', 'positive', 'start exp' or 'premature'.        # Delete column M ('outLabel').        # Identify the start and end times of the experiment.                del_indicies = []        start_time = ''        end_time = ''        list_keywords = ['correct', 'incorrect', 'omission', 'iti', 'premature', 'perseverative', 'present time', 'latency', 'start exp', 'end exp']                for i in range(len(df['SystemMsg'])):            if df.at[i,'SystemMsg'] not in list_keywords:                del_indicies.append(i)            if df.at[i,'SystemMsg'] == 'start':                start_time = df.at[i,'DateTime']            if df.at[i,'SystemMsg'] != 'end':                end_time = df.at[i,'DateTime']                        df = df.drop(del_indicies)        df = df.drop(columns=['outLabel'])                # Ensure that the DateTime column is in a datetime format and not a string.        if type(df['DateTime'].iloc[0]) == str:            possible_formats = [None, '%d/%m/%Y %H.%M.%S.%f']            for form in possible_formats:                df['DateTime'] = pd.to_datetime(df['DateTime'], format=form, errors='ignore')                if type(df['DateTime'].iloc[0]) != str:                    start_time = pd.to_datetime(start_time, format=form)                    end_time   = pd.to_datetime(end_time, format=form)                    break            if type(df['DateTime'].iloc[0]) == str:                print('A new datetime format needs to be included in the code.')                sys.exit()                        # Sort all the rows by the column 'IdLabel'.        # Within those identical entries in 'IdLabel', sort by the column 'DateTime'.                df = df.sort_values(by=['IdLabel','DateTime'], na_position='last')                # Find the length of the longest session in the file.        # A session is a section from 'start exp' to 'end exp'.        # At the same time, if there is no end exp before a start exp, add one in.                best_counter = 0        counter = 0        no_end_exp = []        df.index = list(range(len(df)))                for i in range(len(df['SystemMsg'])):            counter += 1            if df['SystemMsg'].iloc[i] == 'end exp':                if counter > best_counter:                    best_counter = counter                counter = 0            if i!=0 and df['SystemMsg'].iloc[i]=='start exp' and df['SystemMsg'].iloc[i-1]!='end exp':                no_end_exp.append(i-1)                        for ind in no_end_exp:            df.loc[ind+0.5] = df.loc[ind]            df.at[ind+0.5,'DateTime'] = np.nan            df.at[ind+0.5,'SystemMsg'] = 'end exp'        df = df.sort_index()        df.index = list(range(len(df)))                # Organise the sessions in column 'SystemMsg' into separate sheets.                list_labels = []        list_dfs = []        list_cols = []        list_cols_val1 = []        list_cols_time = []        list_titles = []                for i in range(len(df['SystemMsg'])):                        label_name = df['IdLabel'].iloc[i]            system_name = df['SystemMsg'].iloc[i]            msgvalue_name = df['MsgValue1'].iloc[i]            time_name = df['DateTime'].iloc[i]                        # Starting a new rat ID label (in column 'IdLabel').            if (label_name not in list_labels) and (system_name == 'start exp'):                                    time_name = df['DateTime'].iloc[i]                code_name = df['IdRFID'].iloc[i]                list_labels.append(label_name)                                list_dfs.append(pd.DataFrame({'Col 0':[]}))                list_cols.append([])                list_cols_val1.append([])                list_cols_time.append([])                list_titles.append(label_name)                                g_tot_startexp = 0                g_tot_omission = 0                g_tot_correct = 0                g_tot_incorrect = 0                g_tot_premature = 0                g_tot_perseverative = 0                g_tot_endexp = 0                g_tot_trials = 0                        # Starting a new session (in column 'SystemMsg').            elif (label_name in list_labels) and (system_name == 'start exp'):                                time_name = df['DateTime'].iloc[i]                list_cols.append([])                list_cols_val1.append([])                list_cols_time.append([])                        # Recording the event (in column 'SystemMsg').            list_cols[-1].append(system_name)            list_cols_val1[-1].append(msgvalue_name)            list_cols_time[-1].append(time_name)                        # Ending a session (in column 'SystemMsg').            if system_name == 'end exp':                                while len(list_cols[-1]) < best_counter:                    list_cols[-1].append('')                    list_cols_val1[-1].append('')                    list_cols_time[-1].append('')                                    # Add data about each session.                tot_startexp = 0                tot_omission = 0                tot_correct = 0                tot_incorrect = 0                tot_premature = 0                tot_perseverative = 0                tot_endexp = 0                tot_trials = 0                                for event in list_cols[-1]:                    if event == 'start exp':                        tot_startexp += 1                    elif event == 'omission':                        tot_omission += 1                    elif event == 'correct':                        tot_correct += 1                    elif event == 'incorrect':                        tot_incorrect += 1                    elif event == 'premature':                        tot_premature += 1                    elif event == 'perseverative':                        tot_perseverative += 1                    elif event == 'end exp':                        tot_endexp += 1                tot_trials = tot_correct + tot_incorrect + tot_omission                                g_tot_startexp += tot_startexp                g_tot_omission += tot_omission                g_tot_correct += tot_correct                g_tot_incorrect += tot_incorrect                g_tot_premature += tot_premature                g_tot_perseverative += tot_perseverative                g_tot_endexp += tot_endexp                g_tot_trials += tot_trials                                        for j in range(len(list_cols[-1])):                    if list_cols[-1][j] == 'start exp':                        temp_time1 = list_cols_time[-1][j]                    elif list_cols[-1][j] == 'end exp':                        temp_time2 = list_cols_time[-1][j]                len_session = temp_time2 - temp_time1                # Make the session lengths time in minutes.                len_session = len_session.total_seconds() / 60                                if (tot_correct + tot_incorrect) == 0:                    prop_correct_CI = 0                    prop_incorrect_CI = 0                else:                    prop_correct_CI = (tot_correct * 100) / (tot_correct + tot_incorrect)                    prop_incorrect_CI = (tot_incorrect * 100) / (tot_correct + tot_incorrect)                                    if (tot_correct + tot_incorrect + tot_omission) == 0:                    prop_correct_CIO = 0                    prop_incorrect_CIO = 0                    prop_omitted_CIO = 0                else:                    prop_correct_CIO = (tot_correct * 100) / (tot_correct + tot_incorrect + tot_omission)                    prop_incorrect_CIO = (tot_incorrect * 100) / (tot_correct + tot_incorrect + tot_omission)                    prop_omitted_CIO = (tot_omission * 100) / (tot_correct + tot_incorrect + tot_omission)                                if (tot_correct + tot_incorrect + tot_omission + tot_premature + tot_perseverative) == 0:                    prop_premature_CIOPP = 0                    prop_perseverative_CIOPP = 0                else:                       prop_premature_CIOPP = (tot_premature * 100) / (tot_correct + tot_incorrect + tot_omission + tot_premature + tot_perseverative)                    prop_perseverative_CIOPP = (tot_perseverative * 100) / (tot_correct + tot_incorrect + tot_omission + tot_premature + tot_perseverative)                       total_CI  = prop_correct_CI + prop_incorrect_CI                total_CIO = prop_correct_CIO + prop_incorrect_CIO + prop_omitted_CIO                                # Put these statistics above the event data colours.                ex_vals   = []                ex_names  = []                ex_vals  += [ tot_startexp,                 tot_omission,                tot_correct,                tot_incorrect,                tot_premature,                   tot_perseverative,                   tot_endexp,                 tot_trials,                '']                ex_names += ['Number of start exp trials', 'Number of omission trials', 'Number of correct trials', 'Number of incorrect trials', 'Number of premature responses', 'Number of perseverative responses', 'Number of end exp trials', 'Number of trials (C+I+O)', '']                ex_vals  += [ prop_correct_CI,                 prop_incorrect_CI,                 total_CI      ]                ex_names += ['Proportion correct of C+I (%)', 'Proportion incorrect of C+I (%)', 'C+I Total (%)']                ex_vals  += [ prop_correct_CIO,                  prop_incorrect_CIO,                  prop_omitted_CIO,                  total_CIO       ]                ex_names += ['Proportion correct of C+I+O (%)', 'Proportion incorrect of C+I+O (%)', 'Proportion omitted of C+I+O (%)', 'C+I+O total (%)']                ex_vals  += [ prop_premature_CIOPP,                    prop_perseverative_CIOPP                  ]                ex_names += ['Proportion premature of C+I+O+P+P (%)', 'Proportion perseverative of C+I+O+P+P (%)']                ex_vals  += [ len_session,        '']                ex_names += ['Length of session (mins)', '']                                list_cols[-1] = ex_vals + list_cols[-1]                list_cols_val1[-1] = len(ex_vals)*[''] + list_cols_val1[-1]                list_cols_time[-1] = len(ex_vals)*[''] + list_cols_time[-1]                list_dfs[-1]['Col 0'] = ex_names + best_counter*['']                list_dfs[-1]['Col '+str(i*3+1)] = list_cols[-1].copy()                list_dfs[-1]['Col '+str(i*3+2)] = list_cols_val1[-1].copy()                list_dfs[-1]['Col '+str(i*3+3)] = list_cols_time[-1].copy()                                # Add the total columns.                if i==len(df['SystemMsg'])-1 or ((df['IdLabel'].iloc[i+1] not in list_labels) and (df['SystemMsg'].iloc[i+1] == 'start exp')):                                        # Finish the calculations.                    if (g_tot_correct + g_tot_incorrect) == 0:                        g_prop_correct_CI = 0                        g_prop_incorrect_CI = 0                    else:                        g_prop_correct_CI = (g_tot_correct * 100) / (g_tot_correct + g_tot_incorrect)                        g_prop_incorrect_CI = (g_tot_incorrect * 100) / (g_tot_correct + g_tot_incorrect)                                            if (g_tot_correct + g_tot_incorrect + g_tot_omission) == 0:                        g_prop_correct_CIO = 0                        g_prop_incorrect_CIO = 0                        g_prop_omitted_CIO = 0                    else:                        g_prop_correct_CIO = (g_tot_correct * 100) / (g_tot_correct + g_tot_incorrect + g_tot_omission)                        g_prop_incorrect_CIO = (g_tot_incorrect * 100) / (g_tot_correct + g_tot_incorrect + g_tot_omission)                        g_prop_omitted_CIO = (g_tot_omission * 100) / (g_tot_correct + g_tot_incorrect + g_tot_omission)                                            if (g_tot_correct + g_tot_incorrect + g_tot_omission + g_tot_premature + g_tot_perseverative) == 0:                        g_prop_premature_CIOPP = 0                        g_prop_perseverative_CIOPP = 0                    else:                           g_prop_premature_CIOPP = (g_tot_premature * 100) / (g_tot_correct + g_tot_incorrect + g_tot_omission + g_tot_premature + g_tot_perseverative)                        g_prop_perseverative_CIOPP = (g_tot_perseverative * 100) / (g_tot_correct + g_tot_incorrect + g_tot_omission + g_tot_premature + g_tot_perseverative)                               g_total_CI  = g_prop_correct_CI + g_prop_incorrect_CI                    g_total_CIO = g_prop_correct_CIO + g_prop_incorrect_CIO + g_prop_omitted_CIO                                        # Add the total section.                    total_headers = ['Start exp total', 'Omission total', 'Correct total', 'Incorrect total', 'Premature total', 'Perseverative total', 'End exp total', 'Total number of trials (C+I+O)', '']                    total_values  = [   g_tot_startexp,   g_tot_omission,   g_tot_correct,   g_tot_incorrect,   g_tot_premature,   g_tot_perseverative,    g_tot_endexp,                     g_tot_trials, '']                                        total_values    += [ g_prop_correct_CI,               g_prop_incorrect_CI,               g_total_CI    ]                    total_headers   += ['Proportion correct of C+I (%)', 'Proportion incorrect of C+I (%)', 'C+I Total (%)']                    total_values    += [ g_prop_correct_CIO,                g_prop_incorrect_CIO,                g_prop_omitted_CIO,                g_total_CIO,    ]                    total_headers   += ['Proportion correct of C+I+O (%)', 'Proportion incorrect of C+I+O (%)', 'Proportion omitted of C+I+O (%)', 'C+I+O total (%)']                    total_values    += [ g_prop_premature_CIOPP,                  g_prop_perseverative_CIOPP,                  g_tot_startexp,  '']                    total_headers   += ['Proportion premature of C+I+O+P+P (%)', 'Proportion perseverative of C+I+O+P+P (%)', 'Total sessions', '']                                        list_dfs[-1]['Col '+str(i*3+4)] = total_headers + best_counter*['']                    list_dfs[-1]['Col '+str(i*3+5)] = total_values + best_counter*['']        # Color code the entries that came from column 'SystemMsg'.        # This uses the rules in the functions at the top of the code.                df_export = df.style.applymap(text_color, subset = ['SystemMsg', 'MsgValue1']).applymap(cell_color, subset = ['SystemMsg', 'MsgValue1'])                list_dfs_export = list_dfs.copy()        for i in range(len(list_dfs)):            list_dfs_export[i] = list_dfs[i].style.applymap(text_color, subset = pd.IndexSlice[len(ex_names):, list(list_dfs[i].columns.values)[1:-2]]).applymap(cell_color, subset = pd.IndexSlice[len(ex_names):, list(list_dfs[i].columns.values)[1:-2]])            #list_dfs_export[i] = list_dfs[i].style.applymap(text_color).applymap(cell_color).applymap(bold_titles,subset=[''])        # Change the existing data.                if add_data_to_new_file == True:                    with pd.ExcelWriter(export_destination) as writer:                df_export.to_excel(writer, sheet_name='Overall sheet', engine='openpyxl', index=False)                for i in range(len(list_dfs_export)):                    list_dfs_export[i].to_excel(writer, sheet_name=str(list_titles[i]), engine='openpyxl', index=False, header=False)                          elif add_data_to_original_file == True:            with pd.ExcelWriter(import_destination, mode='a', engine='openpyxl') as writer:                df_export.to_excel(writer, sheet_name='Overall sheet', engine='openpyxl', index=False)                for i in range(len(list_dfs_export)):                    list_dfs_export[i].to_excel(writer, sheet_name=str(list_titles[i]), engine='openpyxl', index=False, header=False)            os.rename(import_destination, import_location + 'Organised ' + filename)                # Uncomment this section below to run the code manually.# import_location = 'C:/Users/hazza/Desktop/Phenosys data/Import folder/'# export_location = 'C:/Users/hazza/Desktop/Phenosys data/Export folder/'# add_data_to_new_file = True# add_data_to_original_file = False# f5CSRTT_ITIs_SDs_Together(import_location, export_location, add_data_to_new_file, add_data_to_original_file)