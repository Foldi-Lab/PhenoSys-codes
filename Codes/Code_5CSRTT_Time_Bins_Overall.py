def f5CSRTT_Time_Bins_Overall(import_location, export_location, add_data_to_new_file, add_data_to_original_file, time_step):        import os    import pandas as pd    from openpyxl import load_workbook    import sys    from tqdm import tqdm        # Define functions for color coding.        def text_color(val):                if type(val) != str or 'PI' in val or 'Number' in val:            return 'color: %s' % 'black'            if 'end' in val:            color = '#FFFFFF' # White for 'end'        elif 'start' in val:            color = '#FFFFFF' # White for 'start'        elif 'omis' in val:            color = '#9C5600' # Dark yellow for 'omis'        elif 'posi' in val:            color = '#4E7C3E' # Dark green for 'posi'        elif 'inco' in val:            color = '#9C1B14' # Dark red for 'inco'        elif 'premature' in val:            color = '#FFFFFF' # White for 'premature'                    else:            color = 'black'                    return 'color: %s' % color        def cell_color(val):                 if type(val) != str or 'PI' in val or 'Number' in val:            return 'background-color: %s' % 'none'            if 'end' in val:            color = '#000000' # Black for 'end'        elif 'start' in val:            color = '#6C2C9D' # Purple for 'start'        elif 'omis' in val:            color = '#FCEB9C' # Yellow for 'omis'        elif 'posi' in val:            color = '#C3EFCC' # Green for 'posi'        elif 'inco' in val:            color = '#FBC4CD' # Red for 'inco'        elif 'premature' in val:            color = '#808080' # Grey for 'premature'                    else:            color = 'none'                    return 'background-color: %s' % color        def bold_titles(val):        return 'font-weight: bold'        def remove_rows(lst, list_indicies):        return [x for ind, x in enumerate(lst) if ind in list_indicies]        # Create a loop over every excel file in the import location.        # I also rename "incorrect" to wrong.        import_files = [file for file in os.listdir(import_location) if (file.endswith(".xlsx") and file.startswith("~$")==False)]        for filename in tqdm(import_files, ncols=70):                # Import the excel data                import_name = filename        import_destination = import_location + import_name        export_name = 'Time Bins Overall for ' + import_name        export_destination = export_location + export_name                df = pd.read_excel(import_destination, sheet_name=0, usecols=['DateTime','IdRFID','IdLabel','outLabel','SystemMsg','MsgValue1','MsgValue2','MsgValue3'])        #df = pd.read_excel(import_destination, sheet_name=0, usecols="A,B,C,M,N,O,P,Q")                # Add 'positive' string from column 'outLabel' to column 'SystemMsg'.                for i in range(len(df['outLabel'])):            if df.at[i,'outLabel'] == 'positive':                df.at[i,'SystemMsg'] = df.at[i,'outLabel']                        # Delete rows in the imported data if the entry in column 'SystemMsg' is not 'end exp', 'wrong', 'omission', 'positive' or 'start exp'.        # Also delete column M ('outLabel').                del_indicies = []        start_time = ''        end_time = ''                for i in range(len(df['SystemMsg'])):            if df.at[i,'SystemMsg'] != 'end exp' and df.at[i,'SystemMsg'] != 'incorrect' and df.at[i,'SystemMsg'] != 'omission' and df.at[i,'SystemMsg'] != 'positive' and df.at[i,'SystemMsg'] != 'premature' and df.at[i,'SystemMsg'] != 'start exp':                del_indicies.append(i)            if df.at[i,'SystemMsg'] == 'start':                start_time = df.at[i,'DateTime']            if df.at[i,'SystemMsg'] != 'end':                end_time = df.at[i,'DateTime']                        df = df.drop(del_indicies)        df = df.drop(columns=['outLabel'])                # Ensure that the DateTime column is in a datetime format and not a string.        if type(df['DateTime'].iloc[0]) == str:            possible_formats = [None, '%d/%m/%Y %H.%M.%S.%f']            for form in possible_formats:                df['DateTime'] = pd.to_datetime(df['DateTime'], format=form, errors='ignore')                if type(df['DateTime'].iloc[0]) != str:                    start_time = pd.to_datetime(start_time, format=form)                    end_time   = pd.to_datetime(end_time, format=form)                    break            if type(df['DateTime'].iloc[0]) == str:                print('A new datetime format needs to be included in the code.')                sys.exit()                        # Sort all the rows by the column 'IdLabel'.        # Within those identical entries in 'IdLabel', sort by the column 'DateTime'.                df = df.sort_values(by=['IdLabel','DateTime'], na_position='last')                # Find the length of the longest session in the file.        # A session is a section from 'start exp' to 'end exp'.        # At the same time, if there is no end exp before a start exp, add one in.                best_counter = 0        counter = 0        no_end_exp = []        df.index = list(range(len(df)))                for i in range(len(df['SystemMsg'])):            counter += 1            if df['SystemMsg'].iloc[i] == 'end exp':                if counter > best_counter:                    best_counter = counter                counter = 0            if i!=0 and df['SystemMsg'].iloc[i]=='start exp' and df['SystemMsg'].iloc[i-1]!='end exp':                no_end_exp.append(i-1)                        for ind in no_end_exp:            df.loc[ind+0.5] = df.loc[ind]            df.at[ind+0.5,'DateTime'] = np.nan            df.at[ind+0.5,'SystemMsg'] = 'end exp'        df = df.sort_index()        df.index = list(range(len(df)))                        # Create time bins.                i=0        list_ids = [df['IdLabel'].iloc[0]]        list_dfs_bins = []        list_titles = [df['IdLabel'].iloc[0]]                while i < len(df['DateTime']):            time_list = [0]            dt_list = [df['DateTime'].iloc[i]]                        startexp_list = [0]            positive_list = [0]            omission_list = [0]            incorrect_list = [0]            premature_list = [0]            endexp_list = [0]            idlabel_list = [df['IdLabel'].iloc[i]]                        full_list  = [ startexp_list, positive_list, omission_list, incorrect_list, premature_list, endexp_list]            full_names = ['start exp',   'positive',    'omission',    'incorrect',    'premature',    'end exp'   ]                        while i < len(df['DateTime']) and df['IdLabel'].iloc[i] in list_ids:                                    while df['DateTime'].iloc[i] > dt_list[-1]:                                    time_list.append(time_list[-1] + time_step)                    dt_list.append(dt_list[-1] + pd.Timedelta(minutes=time_step))                    idlabel_list.append(df['IdLabel'].iloc[i])                    for j in range(len(full_names)):                        full_list[j].append(full_list[j][-1])                                 if df['DateTime'].iloc[i] <= dt_list[-1]:                                        for j in range(len(full_names)):                        if df['SystemMsg'].iloc[i] == full_names[j]:                            full_list[j][-1] += 1                                   i += 1                            session_list = []            PI_total = []            PIO_total = []            prop_P_PI = []            prop_I_PI = []            total_prop_PI = []            prop_Po_PIO = []            prop_I_PIO = []            prop_O_PIO = []            total_prop_PIO = []            for j in range(len(startexp_list)):                                entry1 = startexp_list[j]                entry2 = endexp_list[j]                if entry1 - entry2 == 0:                    session_list.append('')                    if j != 0 and endexp_list[j] > endexp_list[j-1]:                        session_list[-1] = entry1                elif entry1 - entry2 != 0:                    session_list.append(entry1)                                PI_total.append(positive_list[j] + incorrect_list[j])                PIO_total.append(positive_list[j] + omission_list[j] + incorrect_list[j])                                if (positive_list[j] + incorrect_list[j]) == 0:                    prop_P_PI.append(0)                    prop_I_PI.append(0)                else:                    prop_P_PI.append(positive_list[j]*100 / (positive_list[j] + incorrect_list[j]))                    prop_I_PI.append(incorrect_list[j]*100 / (positive_list[j] + incorrect_list[j]))                total_prop_PI.append(prop_P_PI[j] + prop_I_PI[j])                if (positive_list[j] + omission_list[j] + incorrect_list[j]) == 0:                    prop_Po_PIO.append(0)                    prop_I_PIO.append(0)                    prop_O_PIO.append(0)                else:                    prop_Po_PIO.append(positive_list[j]*100 / (positive_list[j] + omission_list[j] + incorrect_list[j]))                    prop_I_PIO.append(incorrect_list[j]*100 / (positive_list[j] + omission_list[j] + incorrect_list[j]))                    prop_O_PIO.append(omission_list[j]*100 / (positive_list[j] + omission_list[j] + incorrect_list[j]))                total_prop_PIO.append(prop_Po_PIO[j] + prop_I_PIO[j] + prop_O_PIO[j])                        # Delete rows with a session number of 0 and add a dividing row.            dictionary1 = {'Session number': session_list,   'Time bins (date)': dt_list,         'Time bins (mins)': time_list,       'ID Label': idlabel_list, 'start exp': startexp_list, 'positive': positive_list, 'omission': omission_list, 'incorrect': incorrect_list, 'premature': premature_list, 'end exp': endexp_list, '': len(dt_list)*[''], 'PI total': PI_total, 'PIO total': PIO_total, ' ': len(dt_list)*[''], 'Proportion Po of PI (%)': prop_P_PI, 'Proportion I of PI (%)': prop_I_PI, 'Total of PI Proportions (%)': total_prop_PI, 'Proportion Po of PIO (%)': prop_Po_PIO, 'Proportion I of PIO (%)': prop_I_PIO, 'Proportion O of PIO (%)': prop_O_PIO, 'Total of PIO Proportions (%)': total_prop_PIO}            list_indicies = []            j = 0            while j < len(dictionary1['Session number']):                if j != 0 and dictionary1['Session number'][j] == '' and type(dictionary1['Session number'][j-1]) == int:                    for col in list(dictionary1.keys()):                        dictionary1[col][j] = ''                    list_indicies.append(j)                elif type(dictionary1['Session number'][j]) == int:                    list_indicies.append(j)                j += 1                            for col in list(dictionary1.keys()):                dictionary1[col] = [x for ind, x in enumerate(dictionary1[col]) if ind in list_indicies]            dictionary1['Time bins (date)'] = list(map(str,dictionary1['Time bins (date)']))            entry = pd.DataFrame(dictionary1)            entry['Time bins (date)'] = pd.to_datetime(entry['Time bins (date)'])            list_dfs_bins.append(entry)            if i < len(df['DateTime']):                list_ids.append(df['IdLabel'].iloc[i])                list_titles.append(df['IdLabel'].iloc[i])                        # Add extra time and session columns to the 'Overall sheet', so the sessions can be sliced out of the videos.        current_session = 0        current_idlabel = df['IdLabel'].iloc[0]        session_record = []        video_time = []        video_time_secs = []                for i in range(len(df['DateTime'])):            if current_idlabel != df['IdLabel'].iloc[i]:                current_idlabel = df['IdLabel'].iloc[i]                current_session = 0            if df['SystemMsg'].iloc[i] == 'start exp':                current_session += 1            session_record.append(current_session)            video_time.append(str(df['DateTime'].iloc[i] - start_time))            video_time_secs.append((df['DateTime'].iloc[i] - start_time).total_seconds())                    df.insert(0, 'Video time (ss:mm:hh)', video_time, True)        df.insert(0, 'Video time (secs)', video_time_secs, True)        df.insert(0, 'Session number', session_record, True)                # Color code the entries that came from column 'SystemMsg'.        # This uses the rules in the functions at the top of the code.                df_export = df.style.applymap(text_color).applymap(cell_color)        list_dfs_export = list_dfs_bins.copy()                #for i in range(len(list_dfs_bins)):            #list_dfs_export[i] = list_dfs_bins[i].style.applymap(text_color).applymap(cell_color)            #list_dfs_export[i] = list_dfs[i].style.applymap(text_color).applymap(cell_color).applymap(bold_titles,subset=[''])                    # Change the existing data.            if add_data_to_new_file == True:                    with pd.ExcelWriter(export_destination) as writer:                df_export.to_excel(writer, sheet_name='Overall sheet', engine='openpyxl', index=False)                for i in range(len(list_dfs_export)):                    list_dfs_export[i].to_excel(writer, sheet_name=str(list_titles[i]), engine='openpyxl', index=False, header=True)                          elif add_data_to_original_file == True:            with pd.ExcelWriter(import_destination, mode='a', engine='openpyxl') as writer:                df_export.to_excel(writer, sheet_name='Overall sheet', engine='openpyxl', index=False)                for i in range(len(list_dfs_export)):                    list_dfs_export[i].to_excel(writer, sheet_name=str(list_titles[i]), engine='openpyxl', index=False, header=True)            os.rename(import_destination, import_location + 'Time Bins for ' + filename)                