def fGTPT5_Time_Bins_Overall(import_location, export_location, add_data_to_new_file, add_data_to_original_file, time_step):        import os    import pandas as pd    from openpyxl import load_workbook    import sys    from tqdm import tqdm        # Define functions for color coding.        def text_color(val):                if type(val) != str or 'P+W' in val or 'Number' in val:            return 'color: %s' % 'black'            if 'end' in val:            color = '#FFFFFF' # White for 'end'        elif 'start' in val:            color = '#FFFFFF' # White for 'start'        elif 'omis' in val:            color = '#9C5600' # Dark yellow for 'omis'        elif val == 'positive':            color = '#4E7C3E' # Dark green for 'posi'        elif val == 'wrong':            color = '#9C1B14' # Dark red for 'wrong'                    elif val == 'wrong (WW)':            color = '#000000' # Black for 'wrong (WW)'        elif val == 'positive (WP)':            color = '#000000' # Black for 'positive (WP)'        else:            color = 'black'                    return 'color: %s' % color        def cell_color(val):                 if type(val) != str or 'P+W' in val or 'Number' in val:            return 'background-color: %s' % 'none'            if 'end' in val:            color = '#000000' # Black for 'end'        elif 'start' in val:            color = '#6C2C9D' # Purple for 'start'        elif 'omis' in val:            color = '#FCEB9C' # Yellow for 'omis'        elif val == 'positive':            color = '#C3EFCC' # Green for 'positive'        elif val == 'wrong':            color = '#FBC4CD' # Red for 'wrong'                elif val == 'wrong (WW)':            color = '#FFA500' # Orange for 'wrong (WW)'        elif val == 'positive (WP)':            color = '#FFFF00' # Yellow for 'positive (WP)'        else:            color = 'none'                    return 'background-color: %s' % color        def bold_titles(val):        return 'font-weight: bold'        def remove_rows(lst, list_indicies):        return [x for ind, x in enumerate(lst) if ind in list_indicies]        # Create a loop over every excel file in the import location.        # I also rename "incorrect" to wrong.        import_files = [file for file in os.listdir(import_location) if (file.endswith(".xlsx") and file.startswith("~$")==False)]        for filename in tqdm(import_files, ncols=70):                # Import the excel data                import_name = filename        import_destination = import_location + import_name        export_name = 'Time Bins Overall for ' + import_name        export_destination = export_location + export_name                df = pd.read_excel(import_destination, sheet_name=0, usecols=['DateTime','IdRFID','IdLabel','outLabel','SystemMsg','MsgValue1','MsgValue2','MsgValue3'])        #df = pd.read_excel(import_destination, sheet_name=0, usecols="A,B,C,M,N,O,P,Q")                # Add 'positive' string from column 'outLabel' to column 'SystemMsg'.                for i in range(len(df['outLabel'])):            if df.at[i,'outLabel'] == 'positive':                df.at[i,'SystemMsg'] = df.at[i,'outLabel']                        # Delete rows in the imported data if the entry in column 'SystemMsg' is not 'end exp', 'wrong', 'omission', 'positive' or 'start exp'.        # Also delete column M ('outLabel').                del_indicies = []                for i in range(len(df['SystemMsg'])):            if df.at[i,'SystemMsg'] != 'end exp' and df.at[i,'SystemMsg'] != 'wrong' and df.at[i,'SystemMsg'] != 'omission' and df.at[i,'SystemMsg'] != 'positive' and df.at[i,'SystemMsg'] != 'start exp':                del_indicies.append(i)                        df = df.drop(del_indicies)        df = df.drop(columns=['outLabel'])                # Ensure that the DateTime column is in a datetime format and not a string.        if type(df['DateTime'].iloc[0]) == str:            possible_formats = [None, '%d/%m/%Y %H.%M.%S.%f']            for form in possible_formats:                df['DateTime'] = pd.to_datetime(df['DateTime'], format=form, errors='ignore')                if type(df['DateTime'].iloc[0]) != str:                    start_time = pd.to_datetime(start_time, format=form)                    end_time   = pd.to_datetime(end_time, format=form)                    break            if type(df['DateTime'].iloc[0]) == str:                print('A new datetime format needs to be included in the code.')                sys.exit()                        # Sort all the rows by the column 'IdLabel'.        # Within those identical entries in 'IdLabel', sort by the column 'DateTime'.                df = df.sort_values(by=['IdLabel','DateTime'], na_position='last')                # Find the length of the longest session in the file.        # A session is a section from 'start exp' to 'end exp'.        # At the same time, if there is no end exp before a start exp, add one in.                best_counter = 0        counter = 0        no_end_exp = []        df.index = list(range(len(df)))                for i in range(len(df['SystemMsg'])):            counter += 1            if df['SystemMsg'].iloc[i] == 'end exp':                if counter > best_counter:                    best_counter = counter                counter = 0            if i!=0 and df['SystemMsg'].iloc[i]=='start exp' and df['SystemMsg'].iloc[i-1]!='end exp':                no_end_exp.append(i-1)                        for ind in no_end_exp:            df.loc[ind+0.5] = df.loc[ind]            df.at[ind+0.5,'DateTime'] = np.nan            df.at[ind+0.5,'SystemMsg'] = 'end exp'        df = df.sort_index()        df.index = list(range(len(df)))                # Rename the trials in the first sheet as well.        for i in range(len(df['SystemMsg'])):            if i == 0:                continue            else:                if df['SystemMsg'].iloc[i-1] == 'wrong' or df['SystemMsg'].iloc[i-1] == 'wrong (WW)':                    if df['SystemMsg'].iloc[i] == 'positive':                        df['SystemMsg'].iloc[i] = 'positive (WP)'                    elif df['SystemMsg'].iloc[i] == 'wrong':                        df['SystemMsg'].iloc[i] = 'wrong (WW)'                else:                    continue                        # Create time bins.                i=0        list_ids = [df['IdLabel'].iloc[0]]        list_dfs_bins = []        list_titles = [df['IdLabel'].iloc[0]]                while i < len(df['DateTime']):            time_list = [0]            dt_list = [df['DateTime'].iloc[i]]                        startexp_list = [0]            positive_list = [0]            positiveWP_list = [0]            wrong_list = [0]            wrongWW_list = [0]            endexp_list = [0]            idlabel_list = [df['IdLabel'].iloc[i]]                        full_list  = [ startexp_list, positive_list, positiveWP_list, wrong_list, wrongWW_list, endexp_list]            full_names = ['start exp',   'positive',    'positive (WP)', 'wrong',    'wrong (WW)', 'end exp'   ]                        while i < len(df['DateTime']) and df['IdLabel'].iloc[i] in list_ids:                                    while df['DateTime'].iloc[i] > dt_list[-1]:                                    time_list.append(time_list[-1] + time_step)                    dt_list.append(dt_list[-1] + pd.Timedelta(minutes=time_step))                    idlabel_list.append(df['IdLabel'].iloc[i])                    for j in range(len(full_names)):                        full_list[j].append(full_list[j][-1])                                 if df['DateTime'].iloc[i] <= dt_list[-1]:                                        for j in range(len(full_names)):                        if df['SystemMsg'].iloc[i] == full_names[j]:                            full_list[j][-1] += 1                                   i += 1                            session_list = []            PW_total = []            PWWPWW_total = []            prop_P_PW = []            prop_W_PW = []            total_prop_PW = []            prop_P_PWWPWW = []            prop_W_PWWPWW = []            prop_WP_PWWPWW = []            prop_WW_PWWPWW = []            total_prop_PWWPWW = []            for j in range(len(startexp_list)):                                entry1 = startexp_list[j]                entry2 = endexp_list[j]                if entry1 - entry2 == 0:                    session_list.append('')                    if j != 0 and endexp_list[j] > endexp_list[j-1]:                        session_list[-1] = entry1                elif entry1 - entry2 != 0:                    session_list.append(entry1)                                PW_total.append(positive_list[j] + wrong_list[j])                PWWPWW_total.append(positive_list[j] + positiveWP_list[j] + wrong_list[j] + wrongWW_list[j])                                if (positive_list[j] + wrong_list[j]) == 0:                    prop_P_PW.append(0)                    prop_W_PW.append(0)                else:                    prop_P_PW.append(positive_list[j]*100 / (positive_list[j] + wrong_list[j]))                    prop_W_PW.append(wrong_list[j]*100 / (positive_list[j] + wrong_list[j]))                total_prop_PW.append(prop_P_PW[j] + prop_W_PW[j])                if (positive_list[j] + positiveWP_list[j] + wrong_list[j] + wrongWW_list[j]) == 0:                    prop_P_PWWPWW.append(0)                    prop_W_PWWPWW.append(0)                    prop_WP_PWWPWW.append(0)                    prop_WW_PWWPWW.append(0)                else:                    prop_P_PWWPWW.append(positive_list[j]*100 / (positive_list[j] + positiveWP_list[j] + wrong_list[j] + wrongWW_list[j]))                    prop_W_PWWPWW.append(wrong_list[j]*100 / (positive_list[j] + positiveWP_list[j] + wrong_list[j] + wrongWW_list[j]))                    prop_WP_PWWPWW.append(positiveWP_list[j]*100 / (positive_list[j] + positiveWP_list[j] + wrong_list[j] + wrongWW_list[j]))                    prop_WW_PWWPWW.append(wrongWW_list[j]*100 / (positive_list[j] + positiveWP_list[j] + wrong_list[j] + wrongWW_list[j]))                total_prop_PWWPWW.append(prop_P_PWWPWW[j] + prop_W_PWWPWW[j] + prop_WP_PWWPWW[j] + prop_WW_PWWPWW[j])                        # Delete rows with a session number of 0 and add a dividing row.            dictionary1 = {'Session number': session_list,   'Time bins (date)': dt_list,         'Time bins (mins)': time_list,       'ID Label': idlabel_list, 'start exp': startexp_list, 'positive': positive_list, 'positive (WP)': positiveWP_list, 'wrong': wrong_list, 'wrong (WW)': wrongWW_list, 'end exp': endexp_list, '': len(dt_list)*[''], 'PW total': PW_total, 'PWWPWW total': PWWPWW_total, ' ': len(dt_list)*[''], 'Proportion P of PW (%)': prop_P_PW, 'Proportion W of PW (%)': prop_W_PW, 'Total of PW Proportions (%)': total_prop_PW, 'Proportion P of PWWPWW (%)': prop_P_PWWPWW, 'Proportion W of PWWPWW (%)': prop_W_PWWPWW, 'Proportion WP of PWWPWW (%)': prop_WP_PWWPWW, 'Proportion WW of PWWPWW (%)': prop_WW_PWWPWW, 'Total of PWWPWW Proportions (%)': total_prop_PWWPWW}            list_indicies = []            j = 0            while j < len(dictionary1['Session number']):                if j != 0 and dictionary1['Session number'][j] == '' and type(dictionary1['Session number'][j-1]) == int:                    for col in list(dictionary1.keys()):                        dictionary1[col][j] = ''                    list_indicies.append(j)                elif type(dictionary1['Session number'][j]) == int:                    list_indicies.append(j)                j += 1                            for col in list(dictionary1.keys()):                dictionary1[col] = [x for ind, x in enumerate(dictionary1[col]) if ind in list_indicies]            dictionary1['Time bins (date)'] = list(map(str,dictionary1['Time bins (date)']))            entry = pd.DataFrame(dictionary1)            entry['Time bins (date)'] = pd.to_datetime(entry['Time bins (date)'])            list_dfs_bins.append(entry)            if i < len(df['DateTime']):                list_ids.append(df['IdLabel'].iloc[i])                list_titles.append(df['IdLabel'].iloc[i])                # Color code the entries that came from column 'SystemMsg'.        # This uses the rules in the functions at the top of the code.                df_export = df.style.applymap(text_color).applymap(cell_color)        list_dfs_export = list_dfs_bins.copy()                #for i in range(len(list_dfs_bins)):            #list_dfs_export[i] = list_dfs_bins[i].style.applymap(text_color).applymap(cell_color)            #list_dfs_export[i] = list_dfs[i].style.applymap(text_color).applymap(cell_color).applymap(bold_titles,subset=[''])                    # Change the existing data.            if add_data_to_new_file == True:                    with pd.ExcelWriter(export_destination) as writer:                df_export.to_excel(writer, sheet_name='Overall sheet', engine='openpyxl', index=False)                for i in range(len(list_dfs_export)):                    list_dfs_export[i].to_excel(writer, sheet_name=str(list_titles[i]), engine='openpyxl', index=False, header=True)                          elif add_data_to_original_file == True:            with pd.ExcelWriter(import_destination, mode='a', engine='openpyxl') as writer:                df_export.to_excel(writer, sheet_name='Overall sheet', engine='openpyxl', index=False)                for i in range(len(list_dfs_export)):                    list_dfs_export[i].to_excel(writer, sheet_name=str(list_titles[i]), engine='openpyxl', index=False, header=True)            os.rename(import_destination, import_location + 'Time Bins for ' + filename)                