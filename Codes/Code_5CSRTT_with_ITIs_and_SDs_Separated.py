def f5CSRTT_ITIs_SDs_Separated(import_location, export_location, add_data_to_new_file, add_data_to_original_file):        import os    import pandas as pd    from openpyxl import load_workbook    import sys    from tqdm import tqdm        # Define functions for color coding.        def text_color(val):                val = str(val)        if val == 'correct':            color = '#4E7C3E' # Dark green for 'correct'        elif val == 'incorrect':            color = '#9C1B14' # Dark red for 'incorrect'        elif val == 'omission':            color = '#9C5600' # Dark yellow for 'omission'        elif val == 'iti':            color = '#833C0C' # Dark brown for 'ITI'        elif val == 'premature':            color = '#FFFFFF' # White for 'premature'        elif val == 'perseverative':            color = '#4472C4' # Blue for 'perseverative'        elif val == 'start exp':            color = '#FFFFFF' # White for 'start exp'        elif val == 'end exp':            color = '#FFFFFF' # White for 'end exp'                    elif val == '12':            color = '#C65911' # Orange for 'ITI 12'        elif val == '10':            color = '#7030A0' # Purple for 'ITI 10'        elif val == '8':            color = '#4E7C3E' # Dark green for 'ITI 8'        elif val == '5':            color = '#9C5600' # Dark yellow for 'ITI 5'        elif val == '2':            color = '#9C1B14' # Dark red for 'ITI 2'            else:            color = 'black'                    return 'color: %s' % color        def cell_color(val):                val = str(val)        if val == 'correct':            color = '#C3EFCC' # Green for 'correct'        elif val == 'incorrect':            color = '#FBC4CD' # Red for 'incorrect'        elif val == 'omission':            color = '#FCEB9C' # Yellow for 'omission'        elif val == 'iti':            color = '#F8CBAD' # Skin colour for 'ITI'        elif val == 'premature':            color = '#808080' # Grey for 'premature'        elif val == 'perseverative':            color = '#D9E1F2' # Light blue for 'perseverative'        elif val == 'start exp':            color = '#6C2C9D' # Purple for 'start exp'        elif val == 'end exp':            color = '#000000' # Black for 'end exp'                    elif val == '12':            color = '#DBDBDB' # Grey for 'ITI 12'        elif val == '10':            color = '#C6E0B4' # Light green for 'ITI 10'        elif val == '8':            color = '#C3EFCC' # Green for 'ITI 8'        elif val == '5':            color = '#FCEB9C' # Yellow for 'ITI 5'        elif val == '2':            color = '#FBC4CD' # Red for 'ITI 2'            else:            color = 'none'                    return 'background-color: %s' % color        # Define functions that give a message if there is an error.        def check_SD_and_ITI(SD, ITI):        if SD != 'present time':            return(print('A present time is not identified correctly. ' + str(i) + ' ' + str(j) + ' ' + SD))        if ITI != 'iti' and ITI != 'start exp': # Start exp always refers to a 5 sec ITI.            return(print('An ITI is not identified correctly. ' + str(i) + ' ' + str(j) + ' ' + ITI))            def check_latency(lat):        if lat != 'latency':            return(print('A latency is not identified correctly. ' + str(i) + ' ' + str(j) + ' ' + lat))            #import sys            #return(sys.exit("Error message"))        # Create a loop over every excel file in the import location.        import_files = [file for file in os.listdir(import_location) if (file.endswith(".xlsx") and file.startswith("~$")==False)]        for filename in tqdm(import_files, ncols=70):                # Import the excel data                import_name = filename        import_destination = import_location + import_name        export_name = '(ITIs and SDs Separated) Organised ' + import_name        export_destination = export_location + export_name                df = pd.read_excel(import_destination, sheet_name=0, usecols=['DateTime','IdRFID','IdLabel','outLabel','SystemMsg','MsgValue1','MsgValue2','MsgValue3'])        #df = pd.read_excel(import_destination, sheet_name=0, usecols="A,B,C,M,N,O,P,Q")                # Create an ITI value of 5 next to each 'start exp' event.        for i in range(len(df['SystemMsg'])):            if df.at[i,'SystemMsg'] == 'start exp':                df.at[i,'MsgValue1'] = 5                        # Delete rows in the imported data if the entry in column 'SystemMsg' is not 'end exp', 'incorrect', 'omission', 'positive', 'start exp' or 'premature'.        # Delete column M ('outLabel').        # Identify the start and end times of the experiment.                del_indicies = []        start_time = ''        end_time = ''        list_keywords = ['correct', 'incorrect', 'omission', 'iti', 'premature', 'perseverative', 'present time', 'latency', 'start exp', 'end exp']                for i in range(len(df['SystemMsg'])):            if df.at[i,'SystemMsg'] not in list_keywords:                del_indicies.append(i)            if df.at[i,'SystemMsg'] == 'start':                start_time = df.at[i,'DateTime']            if df.at[i,'SystemMsg'] != 'end':                end_time = df.at[i,'DateTime']                        df = df.drop(del_indicies)        df = df.drop(columns=['outLabel'])        df.index = list(range(len(df)))                # Ensure that the DateTime column is in a datetime format and not a string.        if type(df['DateTime'].iloc[0]) == str:            possible_formats = [None, '%d/%m/%Y %H.%M.%S.%f']            for form in possible_formats:                df['DateTime'] = pd.to_datetime(df['DateTime'], format=form, errors='ignore')                if type(df['DateTime'].iloc[0]) != str:                    start_time = pd.to_datetime(start_time, format=form)                    end_time   = pd.to_datetime(end_time, format=form)                    break            if type(df['DateTime'].iloc[0]) == str:                print('A new datetime format needs to be included in the code.')                sys.exit()                        # Sort all the rows by the column 'IdLabel'.        # Within those identical entries in 'IdLabel', sort by the column 'DateTime'.                df = df.sort_values(by=['IdLabel','DateTime'], na_position='last')                # If there is no end exp before a start exp, add one in.        no_end_exp = []        df.index = list(range(len(df)))                for i in range(len(df['SystemMsg'])):            if i!=0 and df['SystemMsg'].iloc[i]=='start exp' and df['SystemMsg'].iloc[i-1]!='end exp':                no_end_exp.append(i-1)                        for ind in no_end_exp:            df.loc[ind+0.5] = df.loc[ind]            df.at[ind+0.5,'DateTime'] = np.nan            df.at[ind+0.5,'SystemMsg'] = 'end exp'        df = df.sort_index()        df.index = list(range(len(df)))        # Organise the sessions in column 'SystemMsg' into separate sheets.                list_labels = []        list_dfs = []        list_cols = []        list_cols_val1 = []        list_cols_time = []        list_titles = []        session_count = 0                # Create the row titles.        row_titles  = []        row_titles += ['Number of correct trials', 'Number of incorrect trials', 'Number of omission trials', 'Number of premature responses', 'Number of perseverative responses', 'Number of trials (C+I+O)', 'Sum of latencies', 'Number of latencies', 'Average latency']        row_titles += ['Proportion correct of C+I (%)', 'Proportion incorrect of C+I (%)', 'C+I Total (%)']        row_titles += ['Proportion correct of C+I+O (%)', 'Proportion incorrect of C+I+O (%)', 'Proportion omitted of C+I+O (%)', 'C+I+O total (%)']        row_titles += ['Proportion premature of C+I+O+P+P (%)', 'Proportion perseverative of C+I+O+P+P (%)', '']        more_titles  = []        more_titles += ['correct', 'incorrect','omission', 'premature', 'perseverative', 'C+I+O', 'Sum latency', 'Num latency', 'Avg latency']        more_titles += ['Co of C+I', 'In of C+I', 'C+I total']        more_titles += ['Co of C+I+O', 'In of C+I+O', 'Om of C+I+O', 'C+I+O total']        more_titles += ['Pr of C+I+O+P+P', 'Pe of C+I+O+P+P', '']                for i in range(len(df['SystemMsg'])):                            label_name = df['IdLabel'].iloc[i]            system_name = df['SystemMsg'].iloc[i]            msgvalue_name = df['MsgValue1'].iloc[i]            time_name = df['DateTime'].iloc[i]                            # Starting a new rat ID label (in column 'IdLabel').            if (label_name not in list_labels) and (system_name == 'start exp'):                                    time_name = df['DateTime'].iloc[i]                code_name = df['IdRFID'].iloc[i]                list_labels.append(label_name)                                list_dfs.append(pd.DataFrame({'Session number':[], 'ITI (s)':[], '2':[], '5':[], '8':[], '10':[], '12':[], '':[], 'Stimulus duration (present time) (ms)':[], '250':[], '500':[], '1000':[], '2000':[], '4000':[], '8000':[], '16000':[]}))                total_df = pd.DataFrame({'Session number':['Total of Sessions']+18*[''], 'ITI (s)':row_titles, '2':18*[0]+[''], '5':18*[0]+[''], '8':18*[0]+[''], '10':18*[0]+[''], '12':18*[0]+[''], '':18*['']+[''], 'Stimulus duration (present time) (ms)':row_titles, '250':18*[0]+[''], '500':18*[0]+[''], '1000':18*[0]+[''], '2000':18*[0]+[''], '4000':18*[0]+[''], '8000':18*[0]+[''], '16000':18*[0]+['']})                total_df.index = more_titles                list_cols.append([])                list_cols_val1.append([])                list_cols_time.append([])                list_titles.append(label_name)                session_count = 0                        # Starting a new session (in column 'SystemMsg').            elif (label_name in list_labels) and (system_name == 'start exp'):                                time_name = df['DateTime'].iloc[i]                list_cols.append([])                list_cols_val1.append([])                list_cols_time.append([])                        # Recording the event (in column 'SystemMsg').            list_cols[-1].append(system_name)            list_cols_val1[-1].append(msgvalue_name)            list_cols_time[-1].append(time_name)                        # Ending a session (in column 'SystemMsg').            if system_name == 'end exp':                # Create a table about 1 session.                session_count += 1                temp_df = pd.DataFrame({'Session number':['Session ' + str(session_count)]+18*[''], 'ITI (s)':row_titles, '2':18*[0]+[''], '5':18*[0]+[''], '8':18*[0]+[''], '10':18*[0]+[''], '12':18*[0]+[''], '':18*['']+[''], 'Stimulus duration (present time) (ms)':row_titles, '250':18*[0]+[''], '500':18*[0]+[''], '1000':18*[0]+[''], '2000':18*[0]+[''], '4000':18*[0]+[''], '8000':18*[0]+[''], '16000':18*[0]+['']})                temp_df.index = more_titles                                SD_value = 0                ITI_value = 0                lat_value = 0                                # Fill in the totals for each trial or response.                for j in range(len(list_cols[-1])):                                        event = list_cols[-1][j]                                        if event == 'omission' or event == 'correct' or event == 'incorrect':                                                if list_cols[-1][j-1] == 'present time':                            SD_value = str(int(list_cols_val1[-1][j-1]))                        if list_cols[-1][j-2] == 'iti' or list_cols[-1][j-2] == 'start exp':                            ITI_value = str(int(list_cols_val1[-1][j-2]))                        #check_SD_and_ITI(list_cols[-1][j-1], list_cols[-1][j-2])                                                temp_df.at[event, SD_value] += 1                        temp_df.at[event, ITI_value] += 1                                            elif event == 'premature' or event == 'perseverative':                                                if list_cols[-1][j-1] == 'iti' or list_cols[-1][j-1] == 'start exp':                            ITI_value = str(int(list_cols_val1[-1][j-1]))                        #check_SD_and_ITI('present time', list_cols[-1][j-1])                                                temp_df.at[event, ITI_value] += 1                                            elif event == 'latency':                                                # Use the SD and ITI values from the previous trial (only correct) to calculate the latency.                        lat_value = list_cols_val1[-1][j]                        check_latency(list_cols[-1][j])                                                temp_df.at['Sum latency', SD_value] += lat_value                        temp_df.at['Num latency', SD_value] += 1                        if temp_df.at['Num latency', SD_value] == 0:                            temp_df.at['Avg latency', SD_value] = 0                        else:                            temp_df.at['Avg latency', SD_value] = temp_df.at['Sum latency', SD_value] / temp_df.at['Num latency', SD_value]                                                temp_df.at['Sum latency', ITI_value] += lat_value                        temp_df.at['Num latency', ITI_value] += 1                        if temp_df.at['Num latency', ITI_value] == 0:                            temp_df.at['Avg latency', ITI_value] = 0                        else:                            temp_df.at['Avg latency', ITI_value] = temp_df.at['Sum latency', ITI_value] / temp_df.at['Num latency', ITI_value]                # Make calculations about the trial or response totals.                for SD_ITI in ['2', '5', '8', '10', '12', '250', '500', '1000', '2000', '4000', '8000', '16000']:                                        v_correct       = temp_df.at['correct', SD_ITI]                    v_incorrect     = temp_df.at['incorrect', SD_ITI]                    v_omission      = temp_df.at['omission', SD_ITI]                    v_premature     = temp_df.at['premature', SD_ITI]                    v_perseverative = temp_df.at['perseverative', SD_ITI]                    temp_df.at['C+I+O', SD_ITI] = v_correct + v_incorrect + v_omission                                        if (v_correct + v_incorrect) == 0:                        temp_df.at['Co of C+I', SD_ITI] = 0                        temp_df.at['In of C+I', SD_ITI] = 0                        temp_df.at['C+I total', SD_ITI] = 0                    else:                         temp_df.at['Co of C+I', SD_ITI] = (v_correct * 100) / (v_correct + v_incorrect)                        temp_df.at['In of C+I', SD_ITI] = (v_incorrect * 100) / (v_correct + v_incorrect)                        temp_df.at['C+I total', SD_ITI] = temp_df.at['Co of C+I', SD_ITI] + temp_df.at['In of C+I', SD_ITI]                                        if (v_correct + v_incorrect + v_omission) == 0:                        temp_df.at['Co of C+I+O', SD_ITI] = 0                        temp_df.at['In of C+I+O', SD_ITI] = 0                        temp_df.at['Om of C+I+O', SD_ITI] = 0                        temp_df.at['C+I+O total', SD_ITI] = 0                    else:                           temp_df.at['Co of C+I+O', SD_ITI] = (v_correct * 100) / (v_correct + v_incorrect + v_omission)                        temp_df.at['In of C+I+O', SD_ITI] = (v_incorrect * 100) / (v_correct + v_incorrect + v_omission)                        temp_df.at['Om of C+I+O', SD_ITI] = (v_omission * 100) / (v_correct + v_incorrect + v_omission)                        temp_df.at['C+I+O total', SD_ITI] = temp_df.at['Co of C+I+O', SD_ITI] + temp_df.at['In of C+I+O', SD_ITI] + temp_df.at['Om of C+I+O', SD_ITI]                        if (v_correct + v_incorrect + v_omission + v_premature + v_perseverative) == 0:                        temp_df.at['Pr of C+I+O+P+P', SD_ITI] = 0                        temp_df.at['Pe of C+I+O+P+P', SD_ITI] = 0                    else:                           temp_df.at['Pr of C+I+O+P+P', SD_ITI] = (v_premature * 100) / (v_correct + v_incorrect + v_omission + v_premature + v_perseverative)                        temp_df.at['Pe of C+I+O+P+P', SD_ITI] = (v_perseverative * 100) / (v_correct + v_incorrect + v_omission + v_premature + v_perseverative)                          # Add the new session data to the excel sheet and the total section.                list_dfs[-1] = pd.concat([list_dfs[-1], temp_df])                total_df += temp_df                                # Add the total section.                if i==len(df['SystemMsg'])-1 or ((df['IdLabel'].iloc[i+1] not in list_labels) and (df['SystemMsg'].iloc[i+1] == 'start exp')):                                        # Fix the row titles.                    total_df['Session number'] = ['Total of Sessions']+18*['']                    total_df['ITI (s)'] = row_titles                    total_df['Stimulus duration (present time) (ms)'] = row_titles                                        # Finish the calculations.                    for SD_ITI in ['2', '5', '8', '10', '12', '250', '500', '1000', '2000', '4000', '8000', '16000']:                                                v_correct       = total_df.at['correct', SD_ITI]                        v_incorrect     = total_df.at['incorrect', SD_ITI]                        v_omission      = total_df.at['omission', SD_ITI]                        v_premature     = total_df.at['premature', SD_ITI]                        v_perseverative = total_df.at['perseverative', SD_ITI]                            total_df.at['C+I+O', SD_ITI] = v_correct + v_incorrect + v_omission                        if total_df.at['Num latency', SD_ITI] == 0:                            total_df.at['Avg latency', SD_ITI] = 0                        else:                            total_df.at['Avg latency', SD_ITI] = total_df.at['Sum latency', SD_ITI] / total_df.at['Num latency', SD_ITI]                                                                       if (v_correct + v_incorrect) == 0:                            total_df.at['Co of C+I', SD_ITI] = 0                            total_df.at['In of C+I', SD_ITI] = 0                            total_df.at['C+I total', SD_ITI] = 0                        else:                             total_df.at['Co of C+I', SD_ITI] = (v_correct * 100) / (v_correct + v_incorrect)                            total_df.at['In of C+I', SD_ITI] = (v_incorrect * 100) / (v_correct + v_incorrect)                            total_df.at['C+I total', SD_ITI] = total_df.at['Co of C+I', SD_ITI] + total_df.at['In of C+I', SD_ITI]                                                if (v_correct + v_incorrect + v_omission) == 0:                            total_df.at['Co of C+I+O', SD_ITI] = 0                            total_df.at['In of C+I+O', SD_ITI] = 0                            total_df.at['Om of C+I+O', SD_ITI] = 0                            total_df.at['C+I+O total', SD_ITI] = 0                        else:                               total_df.at['Co of C+I+O', SD_ITI] = (v_correct * 100) / (v_correct + v_incorrect + v_omission)                            total_df.at['In of C+I+O', SD_ITI] = (v_incorrect * 100) / (v_correct + v_incorrect + v_omission)                            total_df.at['Om of C+I+O', SD_ITI] = (v_omission * 100) / (v_correct + v_incorrect + v_omission)                            total_df.at['C+I+O total', SD_ITI] = total_df.at['Co of C+I+O', SD_ITI] + total_df.at['In of C+I+O', SD_ITI] + total_df.at['Om of C+I+O', SD_ITI]                                            if (v_correct + v_incorrect + v_omission + v_premature + v_perseverative) == 0:                            total_df.at['Pr of C+I+O+P+P', SD_ITI] = 0                            total_df.at['Pe of C+I+O+P+P', SD_ITI] = 0                        else:                               total_df.at['Pr of C+I+O+P+P', SD_ITI] = (v_premature * 100) / (v_correct + v_incorrect + v_omission + v_premature + v_perseverative)                            total_df.at['Pe of C+I+O+P+P', SD_ITI] = (v_perseverative * 100) / (v_correct + v_incorrect + v_omission + v_premature + v_perseverative)                                          # Add the total section to the excel sheet.                    list_dfs[-1] = pd.concat([list_dfs[-1], total_df])                            # Color code the entries that came from column 'SystemMsg'.        # This uses the rules in the functions at the top of the code.        df_export = df.style.applymap(text_color, subset = ['SystemMsg', 'MsgValue1']).applymap(cell_color, subset = ['SystemMsg', 'MsgValue1'])        list_dfs_export=list_dfs                # Export the data.                if add_data_to_new_file == True:                    with pd.ExcelWriter(export_destination) as writer:                df_export.to_excel(writer, sheet_name='Overall sheet', engine='openpyxl', index=False)                for i in range(len(list_dfs_export)):                    list_dfs_export[i].to_excel(writer, sheet_name=str(list_titles[i]), engine='openpyxl', index=False, header=True)        elif add_data_to_original_file == True:            with pd.ExcelWriter(import_destination, mode='a', engine='openpyxl') as writer:                df_export.to_excel(writer, sheet_name='Overall sheet', engine='openpyxl', index=False)                for i in range(len(list_dfs_export)):                    list_dfs_export[i].to_excel(writer, sheet_name=str(list_titles[i]), engine='openpyxl', index=False, header=True)            os.rename(import_destination, import_location + 'Organised ' + filename)                # Uncomment this section below to run the code manually.# import_location = 'C:/Users/hazza/Desktop/Phenosys data/Import folder/'# export_location = 'C:/Users/hazza/Desktop/Phenosys data/Export folder/'# add_data_to_new_file = True# add_data_to_original_file = False# f5CSRTT_ITIs_SDs_Separated(import_location, export_location, add_data_to_new_file, add_data_to_original_file)