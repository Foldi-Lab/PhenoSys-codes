def fTUNL_Time_Bins_Overall(import_location, export_location, add_data_to_new_file, add_data_to_original_file, time_step):        import os    import pandas as pd    from openpyxl import load_workbook    import copy    import sys    from tqdm import tqdm        # Define functions for color coding.        def text_color(val):                val = str(val)        if val == 'positive':            color = '#4E7C3E' # Dark green for 'positive'        elif val == 'wrong choice':            color = '#9C1B14' # Dark red for 'wrong choice'        elif val == 'start choice':            color = '#9C5600' # Dark yellow for 'start choice'        elif val == 'start exp':            color = '#FFFFFF' # White for 'start exp'        elif val == 'end exp':            color = '#FFFFFF' # White for 'end exp'                    else:            color = 'black'                    return 'color: %s' % color        def cell_color(val):                val = str(val)        if val == 'positive':            color = '#C3EFCC' # Green for 'positive'        elif val == 'wrong choice':            color = '#FBC4CD' # Red for 'wrong choice'        elif val == 'start choice':            color = '#FCEB9C' # Yellow for 'start choice'        elif val == 'start exp':            color = '#6C2C9D' # Purple for 'start exp'        elif val == 'end exp':            color = '#000000' # Black for 'end exp'            else:            color = 'none'                    return 'background-color: %s' % color        # Create a loop over every excel file in the import location.        import_files = [file for file in os.listdir(import_location) if (file.endswith(".xlsx") and file.startswith("~$")==False)]        for filename in tqdm(import_files, ncols=70):                # Import the excel data                import_name = filename        import_destination = import_location + import_name        export_name = 'Time Bins Overall for ' + import_name        export_destination = export_location + export_name                df = pd.read_excel(import_destination, sheet_name=0, usecols=['DateTime','IdRFID','IdLabel','outLabel','SystemMsg','MsgValue1','MsgValue2','MsgValue3'])        #df = pd.read_excel(import_destination, sheet_name=0, usecols="A,B,C,M,N,O,P,Q")                # Add 'positive' string from column 'outLabel' to column 'SystemMsg'.        for i in range(len(df['outLabel'])):            if df.at[i,'outLabel'] == 'positive':                df.at[i,'SystemMsg'] = df.at[i,'outLabel']                        # Delete rows in the imported data if the entry in column 'SystemMsg' is not 'end exp', 'incorrect', 'omission', 'positive', 'start exp' or 'premature'.        # Delete column M ('outLabel').        # Identify the start and end times of the experiment.                del_indicies = []        start_time = ''        end_time = ''        #list_keywords = ['correct', 'incorrect', 'omission', 'iti', 'premature', 'perseverative', 'present time', 'latency', 'start exp', 'end exp']        list_keywords = ['delay', 'start exp', 'end exp', 'positive', 'start iti', 'right choice', 'wrong choice', 'start choice', 'wait poke']                for i in range(len(df['SystemMsg'])):            if df.at[i,'SystemMsg'] not in list_keywords:                del_indicies.append(i)            if df.at[i,'SystemMsg'] == 'start':                start_time = df.at[i,'DateTime']            if df.at[i,'SystemMsg'] != 'end':                end_time = df.at[i,'DateTime']                        df = df.drop(del_indicies)        df = df.drop(columns=['outLabel'])        df.index = list(range(len(df)))                # Ensure that the DateTime column is in a datetime format and not a string.        if type(df['DateTime'].iloc[0]) == str:            possible_formats = [None, '%d/%m/%Y %H.%M.%S.%f']            for form in possible_formats:                df['DateTime'] = pd.to_datetime(df['DateTime'], format=form, errors='ignore')                if type(df['DateTime'].iloc[0]) != str:                    start_time = pd.to_datetime(start_time, format=form)                    end_time   = pd.to_datetime(end_time, format=form)                    break            if type(df['DateTime'].iloc[0]) == str:                print('A new datetime format needs to be included in the code.')                sys.exit()                        # Sort all the rows by the column 'IdLabel'.        # Within those identical entries in 'IdLabel', sort by the column 'DateTime'.                df = df.sort_values(by=['IdLabel','DateTime'], na_position='last')            # Find the length of the longest session in the file.        # A session is a section from 'start exp' to 'end exp'.        # At the same time, if there is no end exp before a start exp, add one in.                best_counter = 0        counter = 0        list_image_positions = []        no_end_exp = []        df.index = list(range(len(df)))                for i in range(len(df['SystemMsg'])):            counter += 1            if df['SystemMsg'].iloc[i] == 'end exp':                if counter > best_counter:                    best_counter = counter                counter = 0                            # At the same time, find all unique image positions.            if (df['SystemMsg'].iloc[i] == 'start choice') and (df['MsgValue1'].iloc[i] not in list_image_positions):                list_image_positions.append(df['MsgValue1'].iloc[i])                        if i!=0 and df['SystemMsg'].iloc[i]=='start exp' and df['SystemMsg'].iloc[i-1]!='end exp':                no_end_exp.append(i-1)                        for ind in no_end_exp:            df.loc[ind+0.5] = df.loc[ind]            df.at[ind+0.5,'DateTime'] = np.nan            df.at[ind+0.5,'SystemMsg'] = 'end exp'        df = df.sort_index()        df.index = list(range(len(df)))                        # The number of right and choices in total, for a given image position and with/without correction need to be found.        # To help with this, create 2 columns that contain values like 'right choice 1 5' or 'wrong choice without correction'.        # df['SystemMsg'] already contains the 'right choice' and 'wrong choice' trials.        df['Image positions']   = len(df['SystemMsg'])*['']        df['Correction trials'] = len(df['SystemMsg'])*['']        image_position = []        current_right_wrong = ''        df.index = list(range(len(df)))                for i in range(len(df['SystemMsg'])):                        if df['SystemMsg'].iloc[i] == 'start choice':                image_position += [df['MsgValue1'].iloc[i]]                        elif df['SystemMsg'].iloc[i] == 'right choice':                df.at[i,'Image positions'] = 'right choice ' + image_position[-1]                if current_right_wrong == 'wrong choice' and len(image_position)!=1 and image_position[-1]==image_position[-2]:                    df.at[i,'Correction trials'] = 'right choice with correction'                else:                    df.at[i,'Correction trials'] = 'right choice without correction'                current_right_wrong = 'right choice'                elif df['SystemMsg'].iloc[i] == 'wrong choice':                df.at[i,'Image positions'] = 'wrong choice ' + image_position[-1]                if current_right_wrong == 'wrong choice' and len(image_position)!=1 and image_position[-1]==image_position[-2]:                    df.at[i,'Correction trials'] = 'wrong choice with correction'                else:                    df.at[i,'Correction trials'] = 'wrong choice without correction'                current_right_wrong = 'wrong choice'                # Create the row labels.                # 'headers_list' refers to the titles in the analysed excel file.        # 'names_list' refers to the names of each trial in the raw excel file.        # For example, 'Right choice total' is the total of the 'right choice' trials in the raw data file.        stats_list = ['Start exp total', 'End exp total', 'Positive total', 'Start choice total', 'Right choice total', 'Wrong choice total']        names_list = ['start exp', 'end exp', 'positive', 'start choice', 'right choice', 'wrong choice']        for image in list_image_positions:            for choice in ['Right choice', 'Wrong choice']:                stats_list += [choice + ' ' + image + ' total']                names_list += [choice.lower() + ' ' + image]        stats_list += ['Right choice with correction total', 'Right choice without correction total',                       'Wrong choice with correction total', 'Wrong choice without correction total']        names_list += ['right choice with correction', 'right choice without correction',                       'wrong choice with correction', 'wrong choice without correction']                # Combine these into a dictionary 'stats'.        # stats.keys() refers to 'names_list' and stats.values() refers to 'stats_list'.        # This only contains the stats that can be counted expliciity.        stats = {}        for i in range(len(stats_list)):            stats[names_list[i]] = stats_list[i]                # Add the rest of the headers, which cannot be counted explicitly, into 'headers_list'.        headers_list  = ['Session number', 'Time bins (date)', 'Time bins (mins)', 'ID label'] + stats_list.copy()        headers_list += ['R+W with correction total',          'R+W without correction total', '']        headers_list += ['Proportion right choice of R+W (%)','Proportion wrong choice of R+W (%)']        for image in list_image_positions:            for choice in ['right choice', 'wrong choice']:                headers_list += ['Proportion ' + choice + ' of R+W ' + image + ' (%)']        headers_list += ['Proportion right choice of R+W with correction (%)',    'Proportion wrong choice of R+W with correction (%)',                         'Proportion right choice of R+W without correction (%)', 'Proportion wrong choice of R+W without correction (%)']        data_list     = [[0] if header != '' else '' for header in headers_list]                # Combine 'headers_list' and 'data_list' into a dictionary 'headers'.        # This contains all the stats which will appear in the analysed file.        headers = {}        for i in range(len(headers_list)):            headers[headers_list[i]] = data_list[i]          empty_values = copy.deepcopy(headers)            # Create time bins.                i=0        list_dfs_bins = []        list_ids = [df['IdLabel'].iloc[0]]        list_titles = [df['IdLabel'].iloc[0]]                while i < len(df['DateTime']):                        headers = copy.deepcopy(empty_values)            headers['Time bins (date)'] = [df['DateTime'].iloc[i]]            headers['ID label'] = [df['IdLabel'].iloc[i]]                        while i < len(df['DateTime']) and df['IdLabel'].iloc[i] in list_ids:                                    while df['DateTime'].iloc[i] > headers['Time bins (date)'][-1]:                                        headers['Time bins (mins)'] += [headers['Time bins (mins)'][-1] + time_step]                    headers['Time bins (date)'] += [headers['Time bins (date)'][-1] + pd.Timedelta(minutes=time_step)]                    headers['ID label']         += [df['IdLabel'].iloc[i]]                    for header in stats.values():                        headers[header] += [headers[header][-1]]                                 if df['DateTime'].iloc[i] <= headers['Time bins (date)'][-1]:                                        for col in ['SystemMsg', 'Image positions', 'Correction trials']:                        if df[col].iloc[i] in stats.keys():                            header = stats[df[col].iloc[i]]                            headers[header][-1] += 1                                i += 1                        # Find the statistics for the trials.            # The first line only contains a start exp total of 1, so let everything stay as 0.            headers['Session number'] = [1]            for j in range(1,len(headers['Start exp total'])):                                entry1 = headers['Start exp total'][j]                entry2 = headers['End exp total'][j]                if entry1 - entry2 == 0:                    headers['Session number'].append('')                    if j != 0 and headers['End exp total'][j] > headers['End exp total'][j-1]:                        headers['Session number'][-1] = entry1                elif entry1 - entry2 != 0:                    headers['Session number'].append(entry1)                    headers['R+W with correction total'] += [headers['Right choice with correction total'][j] + headers['Wrong choice with correction total'][j]]                headers['R+W without correction total'] += [headers['Right choice without correction total'][j] + headers['Wrong choice without correction total'][j]]                                types_right_wrong = [''] + [' with correction', ' without correction'] + [' '+x for x in list_image_positions]                for phrase in types_right_wrong:                    right = headers['Right choice' + phrase + ' total'][j]                    wrong = headers['Wrong choice' + phrase + ' total'][j]                    if (right + wrong) == 0:                        headers['Proportion right choice of R+W' + phrase + ' (%)'] += [0]                        headers['Proportion wrong choice of R+W' + phrase + ' (%)'] += [0]                    else:                        headers['Proportion right choice of R+W' + phrase + ' (%)'] += [(right * 100) / (right + wrong)]                        headers['Proportion wrong choice of R+W' + phrase + ' (%)'] += [(wrong * 100) / (right + wrong)]                            # Delete rows with a session number of 0 and add a dividing row.            #dictionary1 = {'Session number': session_list,   'Time bins (date)': dt_list,         'Time bins (mins)': time_list,       'ID Label': idlabel_list, 'start exp': startexp_list, 'positive': positive_list, 'omission': omission_list, 'incorrect': incorrect_list, 'premature': premature_list, 'end exp': endexp_list, '': len(dt_list)*[''], 'PI total': PI_total, 'PIO total': PIO_total, ' ': len(dt_list)*[''], 'Proportion Po of PI (%)': prop_P_PI, 'Proportion I of PI (%)': prop_I_PI, 'Total of PI Proportions (%)': total_prop_PI, 'Proportion Po of PIO (%)': prop_Po_PIO, 'Proportion I of PIO (%)': prop_I_PIO, 'Proportion O of PIO (%)': prop_O_PIO, 'Total of PIO Proportions (%)': total_prop_PIO}            headers[''] = len(headers['Start exp total'])*['']                list_indicies = []            j = 0            while j < len(headers['Session number']):                if j != 0 and headers['Session number'][j] == '' and type(headers['Session number'][j-1]) == int:                    for col in list(headers.keys()):                        headers[col][j] = ''                    list_indicies.append(j)                elif type(headers['Session number'][j]) == int:                    list_indicies.append(j)                j += 1                            for col in list(headers.keys()):                headers[col] = [x for ind, x in enumerate(headers[col]) if ind in list_indicies]                        headers['Time bins (date)'] = list(map(str,headers['Time bins (date)']))            entry = pd.DataFrame(headers)            entry['Time bins (date)'] = pd.to_datetime(entry['Time bins (date)'])            list_dfs_bins.append(entry)                        if i < len(df['DateTime']):                list_ids.append(df['IdLabel'].iloc[i])                list_titles.append(df['IdLabel'].iloc[i])                # Add extra time and session columns to the 'Overall sheet', so the sessions can be sliced out of the videos.        current_session = 0        current_idlabel = df['IdLabel'].iloc[0]        session_record = []        video_time = []        video_time_secs = []                for i in range(len(df['DateTime'])):            if current_idlabel != df['IdLabel'].iloc[i]:                current_idlabel = df['IdLabel'].iloc[i]                current_session = 0            if df['SystemMsg'].iloc[i] == 'start exp':                current_session += 1            session_record.append(current_session)            video_time.append(str(df['DateTime'].iloc[i] - start_time))            video_time_secs.append((df['DateTime'].iloc[i] - start_time).total_seconds())                    df.insert(0, 'Video time (ss:mm:hh)', video_time, True)        df.insert(0, 'Video time (secs)', video_time_secs, True)        df.insert(0, 'Session number', session_record, True)                # Color code the entries that came from column 'SystemMsg'.        # This uses the rules in the functions at the top of the code.                df_export = df.style.applymap(text_color).applymap(cell_color)        list_dfs_export = list_dfs_bins.copy()                #for i in range(len(list_dfs_bins)):            #list_dfs_export[i] = list_dfs_bins[i].style.applymap(text_color).applymap(cell_color)            #list_dfs_export[i] = list_dfs[i].style.applymap(text_color).applymap(cell_color).applymap(bold_titles,subset=[''])                    # Change the existing data.            if add_data_to_new_file == True:                    with pd.ExcelWriter(export_destination) as writer:                df_export.to_excel(writer, sheet_name='Overall sheet', engine='openpyxl', index=False)                for i in range(len(list_dfs_export)):                    list_dfs_export[i].to_excel(writer, sheet_name=str(list_titles[i]), engine='openpyxl', index=False, header=True)                          elif add_data_to_original_file == True:                with pd.ExcelWriter(import_destination, mode='a', engine='openpyxl') as writer:                df_export.to_excel(writer, sheet_name='Overall sheet', engine='openpyxl', index=False)                for i in range(len(list_dfs_export)):                    list_dfs_export[i].to_excel(writer, sheet_name=str(list_titles[i]), engine='openpyxl', index=False, header=True)            os.rename(import_destination, import_location + 'Time Bins for ' + filename)# Uncomment this section below to run the code manually.# import_location = 'C:/Users/hazza/Desktop/Phenosys data/Import folder/'# export_location = 'C:/Users/hazza/Desktop/Phenosys data/Export folder/'# add_data_to_new_file = True# add_data_to_original_file = False# time_step = 1# f5CSRTT_Time_Bins_Sessions(import_location, export_location, add_data_to_new_file, add_data_to_original_file, time_step)