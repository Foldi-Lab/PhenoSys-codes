# import_destination_excel = 'E:\GTPT2-22.06.06.sys10.xlsx'# import_destination_video = 'E:/220607_Sys10_Trim.mp4'# export_location_video    = 'E://'# video_format             = '.mp4'def fVideo_Snipping(import_destination_excel, import_destination_video, export_location_video, video_format):        import pandas as pd    import datetime    import sys    from tqdm import tqdm    import numpy as np    import os    import subprocess as sp    from moviepy.config import get_setting    from moviepy.tools import subprocess_call        # The original moviepy.video.io.ffmpeg_tools.ffmpeg_extract_subclip function    # does not work with all videos.    # I edited the line commented below.    def ffmpeg_extract_subclip(filename, t1, t2, targetname=None):        """ Makes a new video file playing video file ``filename`` between            the times ``t1`` and ``t2``. """        name, ext = os.path.splitext(filename)        if not targetname:            T1, T2 = [int(1000*t) for t in [t1, t2]]            targetname = "%sSUB%d_%d.%s" % (name, T1, T2, ext)        cmd = [get_setting("FFMPEG_BINARY"),"-y",               "-ss", "%0.2f"%t1,               "-i", filename,               "-t", "%0.2f"%(t2-t1),               # The line below used to be:               # "-map", "0", "-vcodec", "copy", "-acodec", "copy", targetname]               "-c", "copy", targetname]        # I also added "logger=None" to the line below, because I have a loading        # bar in the python console already.        subprocess_call(cmd, logger=None)        # Import the excel data        df = pd.read_excel(import_destination_excel, sheet_name=0, usecols=['DateTime','IdRFID','IdLabel','outLabel','SystemMsg','MsgValue1','MsgValue2','MsgValue3'])    #df = pd.read_excel(import_destination, sheet_name=0, usecols="A,B,C,M,N,O,P,Q")                # Delete rows in the imported data if the entry in column 'SystemMsg' is not 'end exp', 'wrong', 'omission', 'positive' or 'start exp'.    # Also delete column M ('outLabel').        del_indicies = []    start_time = ''    end_time = ''        for i in range(len(df['SystemMsg'])):        if df.at[i,'SystemMsg'] != 'end exp' and df.at[i,'SystemMsg'] != 'start exp':            del_indicies.append(i)        if df.at[i,'SystemMsg'] == 'start':            start_time = df.at[i,'DateTime']            title = df.at[i,'DateTime']        if df.at[i,'SystemMsg'] != 'end':            end_time = df.at[i,'DateTime']                df = df.drop(del_indicies)    df = df.drop(columns=['outLabel'])        # Ensure that the DateTime column is in a datetime format and not a string.    if type(df['DateTime'].iloc[0]) == str:        possible_formats = [None, '%d/%m/%Y %H.%M.%S.%f']        for form in possible_formats:            df['DateTime'] = pd.to_datetime(df['DateTime'], format=form, errors='ignore')            if type(df['DateTime'].iloc[0]) != str:                start_time = pd.to_datetime(start_time, format=form)                end_time   = pd.to_datetime(end_time, format=form)                break        if type(df['DateTime'].iloc[0]) == str:            print('A new datetime format needs to be included in the code.')            sys.exit()                # Sort all the rows by the column 'IdLabel'.    # Within those identical entries in 'IdLabel', sort by the column 'DateTime'.        df = df.sort_values(by=['IdLabel','DateTime'], na_position='last')        # If there is no end exp before a start exp, add one in.        no_end_exp = []    df.index = list(range(len(df)))        for i in range(len(df['SystemMsg'])):        if i!=0 and df['SystemMsg'].iloc[i]=='start exp' and df['SystemMsg'].iloc[i-1]!='end exp':            no_end_exp.append(i-1)                for ind in no_end_exp:        df.loc[ind+0.5] = df.loc[ind]        df.at[ind+0.5,'DateTime'] = np.nan        df.at[ind+0.5,'SystemMsg'] = 'end exp'    df = df.sort_index()    df.index = list(range(len(df)))        # If the last session never had an 'end exp', fill that with the end of the experiment.    df['DateTime'] = df['DateTime'].fillna(end_time)                # Add extra time and session columns to 'df', so the sessions can be sliced out of the videos.    current_session = 0    current_idlabel = df['IdLabel'].iloc[0]    session_record = []    video_time = []    video_time_secs = []        for i in range(len(df['DateTime'])):        if current_idlabel != df['IdLabel'].iloc[i]:            current_idlabel = df['IdLabel'].iloc[i]            current_session = 0        if df['SystemMsg'].iloc[i] == 'start exp':            current_session += 1        session_record.append(current_session)        video_time.append(str(df['DateTime'].iloc[i] - start_time))        video_time_secs.append((df['DateTime'].iloc[i] - start_time).total_seconds())            df.insert(0, 'Video time (ss:mm:hh)', video_time, True)    df.insert(0, 'Video time (secs)', video_time_secs, True)    df.insert(0, 'Session number', session_record, True)        # Find how many unique videos will be created.    videos = 'Session '+df['Session number'].astype(str)+' '+df['IdLabel'].astype(str)    num_videos = len(videos.unique())    pbar = tqdm(total=num_videos) # Make a progress bar based on the number of videos snipped.        # Create a loop over all the trials and export a video after every 'end exp'.        start_time = 0    end_time = 0    time_intervals = []        for i in range(len(df['DateTime'])):                if df['SystemMsg'].iloc[i] == 'start exp':            start_time = df['Video time (secs)'].iloc[i]            #print(start_time)        elif df['SystemMsg'].iloc[i] == 'end exp':            end_time = df['Video time (secs)'].iloc[i]            #print(end_time)            time_intervals.append([start_time, end_time])            idlabel = df['IdLabel'].iloc[i]            session_number = df['Session number'].iloc[i]                        # Change the start time by -30 secs and the end time by +30 secs.            start_time = start_time - 30            end_time = end_time + 30            s_time= str(datetime.timedelta(seconds=round(start_time))).replace(':', '-')            e_time= str(datetime.timedelta(seconds=round(end_time))).replace(':', '-')            title_date = str(title.date()).replace(':','-')                        # Extract the clip from the video.            output_name = str(idlabel) + ' Session ' + str(session_number) + ' (' + title_date + ')'            ffmpeg_extract_subclip(import_destination_video, start_time, end_time, targetname = export_location_video + output_name + video_format)            pbar.update(1) # Update the progress bar.                pbar.close() # End the progress bar.